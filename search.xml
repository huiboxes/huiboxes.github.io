<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>金融量化分析——股票和量化投资基础</title>
    <url>/2020/04/01/PY-first-stock-related/</url>
    <content><![CDATA[<p>&emsp;&emsp;对真正懂金融的人来说运作资本易如反掌，钱生钱生生不息。因为懂金融的不多，也就是经济学中的“稀缺”的概念。信息不对等，那么懂金融的可以比常人更早一步获取信息。了解点金融学（基础是经济学）绝对是不会吃亏的。狭义来说，一般人玩金融就是股票、基金、期货、国债（风险极小）。风险系数是期货 <strong>&gt;</strong> 股票 <strong>&gt;</strong> 基金 <strong>&gt;</strong> 国债，风险越大收益自然也越大。这里简单介绍下作为金融三大支柱之一的<strong>股票</strong>的一些基本概念。</p>
<h2 id="股票基本概念"><a href="#股票基本概念" class="headerlink" title="股票基本概念"></a>股票基本概念</h2><p>&emsp;&emsp;股票是股份公司发给出资人的一种凭证，股票的持有者就是股份公司的股东。不是所有公司都能发股票，只有股份公司可以发股票。能发股票不代表可以向市场上发放，也就是卖给其他人。只有上市公司才可以通过证券交易所公开向社会增发股票来募集资金。公司要有一定的实力才能允许上市，否则一直赔就是坑股民，所以很多创业企业家的梦想就是独立做大到上市。</p>
<p>&emsp;&emsp;股票是有面值和市值的，面值表示股票票面上写的金额，市值表示它实际的市场价值。通常说股价就是说的市值。面值是决定每股在公司股份的比例的 ，市值是决定投资人的收益的。一般而言，股票在第一次发行时，其发行价是不会低于其面值的，而随着市场的波动，其有时会高于面值，有时也会低于面值。 </p>
<p>&emsp;&emsp;股票可以作为出资证明，说明你是这个公司的股东，理论上可以参加股东大会对公司经营发表意见（前提是要买非常多的股份）。通过股票的获利主要是两种方式：一种是公司分红，比如说你持有这个公司的股票，那么这个公司会定期或者不定期的分红。比如你每持有10股就给三毛钱，或者每十股增三股。靠分红赚钱的话收益非常小，更多人是靠交易获利。通过股票价格的波动，低价买高价卖，中间的差价就是盈利。</p>
<h2 id="股票分类"><a href="#股票分类" class="headerlink" title="股票分类"></a>股票分类</h2><h3 id="股票有按业绩分类："><a href="#股票有按业绩分类：" class="headerlink" title="股票有按业绩分类："></a>股票有按业绩分类：</h3><ul>
<li>蓝筹股：资本雄厚、信誉优良的公司的股票（中石化、中石油、中铁等）</li>
<li>绩优股：业绩优良的公司的股票（贵州茅台、中国联通、中航高科等）</li>
<li>ST股：特别处理股票，连续两年亏损或每股净资产低于股票面值</li>
</ul>
<h3 id="按上市地区分类："><a href="#按上市地区分类：" class="headerlink" title="按上市地区分类："></a>按上市地区分类：</h3><ul>
<li>A股：中国大陆上市，人名币认购买卖( <code>T + 1</code>,涨跌幅10%,国人通常讨论A股)</li>
<li>B股：中国大陆上市，外币认购买卖( <code>T + 1</code>, <code>T + 3</code> )</li>
<li>H股：中国香港上市（ <code>T + 0</code>，涨跌幅不设限制）</li>
<li>N股：美国纽约上市</li>
<li>S股：新加坡上市</li>
</ul>
<p>&emsp;&emsp;不同地区上市的股票交易规则也不一样，就好比A股实行<code>T + 1</code>的制度和涨跌幅10%的限制。<code>T+1</code>的比方：今天我买了200股中国人寿的股票，那至少要第二天我才能把这200股卖出去，手头除了这200股其它的中国人寿的股票不受影响。常听到的跌停涨停就是股票价格相比昨天收盘时的价格涨或者跌了10%。B股的<code>T＋１</code>指的是交易按照这个制度，股票套现的制度按照<code>T+3</code>也就是3天后才能套现。</p>
<h2 id="股票市场的构成"><a href="#股票市场的构成" class="headerlink" title="股票市场的构成"></a>股票市场的构成</h2><ul>
<li>上市公司（发股票的）</li>
<li>投资者（买股票的，包括机构投资者）</li>
<li>证监会（监察股市的组织，避免影响市场的行为，例如暗中操作股价）、证券业协会（发行业资格证的）、交易所（交易场所，不允许在其它地方交易）</li>
<li>证券中介机构（个人无法找交易所买，只有通过中介机构）</li>
</ul>
<h3 id="交易所"><a href="#交易所" class="headerlink" title="交易所"></a>交易所</h3><ul>
<li>上海证券交易所（上交）：只有一个主板（沪指或者上证指数）</li>
<li>深圳证券交易所（深交）：<ul>
<li>主板：大型成熟企业（深成指）</li>
<li>中小板：经营规模较小（中小板指）</li>
<li>创业板：尚处于成长期的创业企业（创业板指）</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;交易所是分板块的，板块上会有很多股票的表现综合在一起形成的指数 ，也就是大盘。大盘看起来和股价很相似的曲线，但它不是某一支股票。大盘可以反映当前市场总体的态势，牛市就是总体都在涨，熊市就是整体都在跌。深交所有三个板块。</p>
<h2 id="影响股价的因素"><a href="#影响股价的因素" class="headerlink" title="影响股价的因素"></a>影响股价的因素</h2><ul>
<li>市场内部因素</li>
<li>基本面因素</li>
<li>政策因素</li>
</ul>
<p>&emsp;&emsp;市场内部因素主要指买和卖的的关系，买的人多卖的人少就会涨，卖的人少买的人多就会跌。价格根据供求关系波动。基本面因素指公司营收状况，懂金融的人都会分析公司的财务报表、营收额、市盈率、市净率等来预测股票是否适合买入。政策因素就非常宽泛而且很难预测，打个比方，如果国家提高存款利率，相当于国家鼓励人们把钱存进银行而不是留在市场。   对于股价通常都有影响，到了股票上涨跌的体现就很难说。</p>
<h2 id="股票买卖（A股）"><a href="#股票买卖（A股）" class="headerlink" title="股票买卖（A股）"></a>股票买卖（A股）</h2><ul>
<li><p>委托买卖股票</p>
<ul>
<li>个人不能直接买卖，需要在券商开户，进行委托购买</li>
</ul>
</li>
<li><p>股票交易日：法定节假日和交易所修市日以外的周一到周五</p>
</li>
<li><p>股票交易时间：</p>
<ul>
<li><code>9：15 - 9：25</code>         开盘集合竞价时间（为了定出今天的开盘价）</li>
<li><code>9：30 - 11：30</code>       前市，连续竞价时间</li>
<li><code>13：00 - 15：00</code>     后市，连续竞价时间</li>
<li><code>14：57 - 15：00</code>     深交所收盘集合竞价时间（决定今天的收盘价，上交所没有）</li>
</ul>
<p>注意：还有<code>T+1</code>制度和涨跌停10%的限制。</p>
</li>
</ul>
<h2 id="K线图"><a href="#K线图" class="headerlink" title="K线图"></a>K线图</h2><p><img src="k.png" alt="k线图"></p>
<p>​        K线图：    每天的股价表现综合为一个K线图。类似‘中’的符号，红色是张，绿色是跌；上边界代表当天的收盘价，下边界表示当天的开盘价；线的顶端表示当天的最高价，最低端表示当天的最低价。绿色的上下边界代表的与红色相反，最高价和最低价和红色的看法一样。可以通过K线看出某个时段股价的走势。蓝、黄、粉和绿这些线条表示的是均线（多少日内平均的走势），越接近k线走势就是越短期的均线。越短期的均线波动越明显，显得波动比价频繁、波动大。通常来说，短期均线如果下穿长期均线，就是要跌的预兆，上穿均线就是要涨。上穿的交叉线也叫金叉，下穿的交叉线叫做死叉。双均线是有滞后性，它不是实时显示的。所以根本不可能存在绝对盈利的策略，买股票就是博一个概率。</p>
<h2 id="金融分析"><a href="#金融分析" class="headerlink" title="金融分析"></a>金融分析</h2><ul>
<li>基本面分析<ul>
<li>宏观经济面分析：国家的财政政策、货币政策等</li>
<li>行业分析（）</li>
<li>公司分析：财务数据、业绩报告等</li>
</ul>
</li>
<li>技术面分析：各项技术指标<ul>
<li>K线</li>
<li>平均线</li>
<li>KDJ</li>
<li>MACD</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="金融量化投资"><a href="#金融量化投资" class="headerlink" title="金融量化投资"></a>金融量化投资</h2><ul>
<li>量化投资：利用计算机技术并且采用一定的数学模型去实践投资理念，实现投资策略的过程。</li>
<li>量化投资的优势：<ul>
<li>避免主观情绪、人性弱点和认知偏差，选择更加客观（社会经济学）</li>
<li>能同时包括多角度的观察和多层次的模型（大数据+数据可视化）</li>
<li>及时跟踪市场变化，不断发现新的统计模型，寻找交易机会（自动化）</li>
<li>在决定投资策略后，能通过回测验证其效果（机器学习）</li>
</ul>
</li>
</ul>
<h2 id="量化策略"><a href="#量化策略" class="headerlink" title="量化策略"></a>量化策略</h2><ul>
<li>量化策略：通过一套固定的逻辑来分析、判断和决策，自动化地进行股票交易</li>
<li>核心内容<ul>
<li>选股</li>
<li>择时</li>
<li>仓位管理</li>
<li>止盈止损</li>
</ul>
</li>
<li>策略的周期<ul>
<li>产生想法/学习知识</li>
<li>实现策略：Python</li>
<li>校验策略：回测/模拟交易</li>
<li>实盘交易</li>
<li>优化策略/放弃策略</li>
</ul>
</li>
</ul>
<h2 id="Python实现量化投资"><a href="#Python实现量化投资" class="headerlink" title="Python实现量化投资"></a>Python实现量化投资</h2><ul>
<li>Numpy：数值计算</li>
<li>pandas：数据分析</li>
<li>Matplotlib：图标绘制</li>
</ul>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>金融常识</tag>
        <tag>金融量化基础</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中Proxy</title>
    <url>/2020/03/31/JS-Proxy/</url>
    <content><![CDATA[<p>&emsp;&emsp;Proxy翻译成中文是代理的意思，可以拦截对对象的操作然后进行你给定的操作。先上例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _data = &#123;</span><br><span class="line">            name: <span class="string">'hui'</span>,</span><br><span class="line">            age: <span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(_data,&#123;	</span><br><span class="line">            <span class="keyword">set</span>(obj,name,value)&#123;	</span><br><span class="line">            	<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>被修改成了<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">data.name = <span class="string">'box'</span>  <span class="comment">// set被触发，控制台输出 'ame被修改成了box'</span></span><br><span class="line"><span class="built_in">console</span>.log(data.name) <span class="comment">// 'hui'  因为被set拦截所以值没被修改</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码<code>data</code>就是一个<code>Proxy</code>实例，在生成实例时传入了两个对象。第二个对象中的<code>set</code>方法是是自带的，当传入的第一个对象的值要被修改时就拦截这个操作并且执行这个<code>set</code>方法。第二个参数代表被修改的那个值，第三个代表被修改成的那个值。</p>
<p>&emsp;&emsp;除了<code>set</code>方法外，还有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>()   // 方法用于拦截对象的读取属性操作。</span><br><span class="line">has() // 方法是针对in操作符的代理方法。</span><br><span class="line">apply() // 方法用于拦截函数的调用</span><br><span class="line">construct() //  方法用于拦截 new 操作符，为可使new操作符在生成的Proxy对象上生效，用于初始化代理的目标对象自身必须具有【Construct】内部方法（即 new target 必须是有效的）。</span><br><span class="line">defineProperty() // 用于拦截对对象的object.defineProperty()操作;</span><br><span class="line">deleteProperty() // 方法用于拦截对对象属性的delete操作。</span><br><span class="line">handler.getOwnPropertyDrscriptor() // 方法是Object.getOwnPropertyDescriptor()的钩子。</span><br><span class="line">handler.getPrototypeOf() // 是一个代理方法，当读取代理对象的原型时，该方法就会被调用。</span><br><span class="line">handler.isExtensible() // 用于拦截对对象的Object.isExtensible()。</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Proxy</tag>
        <tag>ES6</tag>
        <tag>数据绑定</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据类型</title>
    <url>/2020/03/29/PY-DataType/</url>
    <content><![CDATA[<p>&emsp;&emsp;Python3中有六个标准的数据类型：<code>Number</code>（数字型）、<code>String</code>（字符串）、<code>List</code>（列表）、<code>Tuple</code>（元组）、<code>Set</code>（集合）、<code>Dictionary</code>（字典）。 </p>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>&emsp;&emsp;在<code>Python3</code>中，数字分为<code>int</code>、<code>float</code>、<code>bool</code>、<code>complex</code>。所有的整数都在int范围内（<code>-∞~∞</code>），如果内存足够<code>Python</code>可以表示任意长度的数字。<code>float</code>表示小数，可以使用科学计数标志e或E表示，如 <code>1.2e+10</code> 。<code>True</code>和<code>False</code>（也可以是<code>0</code>和<code>1</code>）是<code>bool</code>型。<code>Python</code>的复数常量写成实部+虚部的写法，虚部以j或J结尾如 <code>3+4j，3J</code>，通常不会用到复数。</p>
<p>&emsp;&emsp;<code>Python</code>中整数可以以十进制、二进制、八进制、十六进制表示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0b11</span>		<span class="comment"># 二进制是以0b开头的，表示十进制的3</span></span><br><span class="line"><span class="number">0o11</span>		<span class="comment"># 八进制是以0o开头的，表示十进制的9</span></span><br><span class="line"><span class="number">0x11</span>		<span class="comment"># 十六进制是以0x开头的，表示十进制的17</span></span><br></pre></td></tr></table></figure>

<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>&emsp;&emsp;字符串是单个字符的字符串的序列。以下此种都是字符串，三个单引号与三个双引号可以定义多行字符串，单个自能用来定义单行字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">' string '</span></span><br><span class="line"><span class="string">" string "</span></span><br><span class="line"><span class="string">''' string '''</span></span><br><span class="line"><span class="string">""" string """</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以使用<code>format</code>和<code>%</code>进行格式化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'8+1=&#123;i&#125;'</span>.format&#123;<span class="number">5</span>+<span class="number">3</span>&#125; <span class="comment"># i相当于1个占位符</span></span><br><span class="line"><span class="string">'5+3=%i'</span>%(<span class="number">5</span>+<span class="number">3</span>)		  <span class="comment"># i是类型</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;字符串可以用<code>len()</code>获取字符串中字符的个数（字符串长度）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">'hjk'</span></span><br><span class="line">print(len(s1)) <span class="comment"># 输出3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;字符串中某些字符需要用转义符来表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'\n '</span>)		<span class="comment"># 换行符，将光标位置移到下一行开头。</span></span><br><span class="line">print(<span class="string">'\r '</span>)		<span class="comment"># 回车符，将光标位置移到本行开头。</span></span><br><span class="line">print(<span class="string">'\t '</span>)		<span class="comment"># 水平制表符，也即 Tab 键，一般相当于四个空格。</span></span><br><span class="line">print(<span class="string">'\b '</span>)		<span class="comment"># 退格（Backspace），将光标位置移到前一列。</span></span><br><span class="line">print(<span class="string">'\' '</span>)		<span class="comment"># 单引号</span></span><br><span class="line">print(<span class="string">'\''</span> <span class="string">')		# 双引号</span></span><br><span class="line"><span class="string">print('</span>\\ <span class="string">')		# \符号</span></span><br><span class="line"><span class="string">print('</span>\a <span class="string">')		# 在控制台输出电脑会响一声</span></span><br></pre></td></tr></table></figure>

<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>&emsp;&emsp;列表是一个任意类型的对象的位置相关的有序集合，它没有固定的大小。与<code>JavaScript</code>中的数组很类似，里面可以放任意类型的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student = [<span class="string">'张三'</span>,<span class="string">'李四'</span>,<span class="string">'王五'</span>]</span><br><span class="line">worker = [<span class="string">'孙七'</span>,<span class="string">'周天'</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;更改列表的长度可以通过下面的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student.append(<span class="string">'赵六'</span>)   <span class="comment"># 向列表后增加一个元素 ['张三','李四','王五','赵六']</span></span><br><span class="line">student.extend(worker)  <span class="comment"># 向列表后追加一个列表 ['张三','李四','王五','赵六','孙七','周天']</span></span><br><span class="line">student.insert(<span class="number">2</span>,<span class="string">'吴九'</span>) <span class="comment"># 向列表第3个位置插入一个元素 ['张三','李四','吴九','王五',...]</span></span><br><span class="line"><span class="keyword">del</span> student[<span class="number">1</span>]          <span class="comment"># 删除列表第2个元素 ['张三','吴九','王五',...]</span></span><br><span class="line">student.pop()			<span class="comment"># 删除列表追最后一个元素，可以在方法内传入一个索引，删除索引处元素</span></span><br><span class="line">student.remove(<span class="string">"张三"</span>)   <span class="comment"># 删除列表中的张三，如果列表中没有要删除的元素就会报错</span></span><br></pre></td></tr></table></figure>

<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>&emsp;&emsp;与列表类似，但是元组的元素是不能修改的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = (<span class="number">100</span>,<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Dict（字典）"><a href="#Dict（字典）" class="headerlink" title="Dict（字典）"></a>Dict（字典）</h2><p>&emsp;&emsp;与<code>JavaScript</code>中的对象很相似，字典是一系列键值对的组合（哈希表），<code>Python</code>中任何对象都可以作为字典的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'xiaoming'</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span>		<span class="comment">#如果后面有重复的键，后面的值会覆盖前面的值</span></span><br><span class="line">&#125;</span><br><span class="line">print(student[<span class="string">'name'</span>])		<span class="comment"># 输出xiaoming</span></span><br></pre></td></tr></table></figure>

<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>&emsp;&emsp;集合是一个无序不，重复元素的序列。 集合使用大括号{}表示 ,与字典类似，但是只有键，没有值，所以要元素不重复。通常用来 关系测试和消除重复元素 。要声明一个空集合要用<code>set()</code>方法，也可以用它将列表转换成集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">se1 = &#123;<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">print(set(li))  <span class="comment"># 输出 [3,5,9,7]</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这六种类型中，<code>list</code>、<code>dict</code>、<code>set</code>都是可变的数据类型，<code>number</code>、<code>string</code>和<code>tuple</code>都是不可变的数据类型（ 可变数据类型更改值后，内存地址不发生改变。不可变数据类型更改值后，内存地址发生改变 ）。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据类型</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>图像常识</title>
    <url>/2020/03/25/imgae-k/</url>
    <content><![CDATA[<h2 id="像素与尺寸"><a href="#像素与尺寸" class="headerlink" title="像素与尺寸"></a>像素与尺寸</h2><p>&emsp;&emsp;一个图片的大小通常用以像素为单位。比如：“一张尺寸为1080*1920的图片”，其含义是指一张图片横向（长的那方）有1920像素，纵向有（稍短的那方）1080像素，总共大小就是这么多个像素点。通过PhotoShop将图片一直放大N倍可看到图片是由一个一个的小个子组成的，一个小个子就是一个像素点。</p>
<h2 id="位图与矢量图"><a href="#位图与矢量图" class="headerlink" title="位图与矢量图"></a>位图与矢量图</h2><p>&emsp;&emsp;前面说到放大图片可以看到像素点，这就是位图的特征。由于横纵方向像素点固定，放大或者缩小越多，图片失真就越严重。矢量图与之相反，无论放大或缩小多少都不会受到影响，因为它不是固定的。颜色、形状、轮廓、大小和屏幕位置都是通过通过公式描述的。SVG做出来的就是矢量图。矢量图虽然不容易失真，但是如果图像细节比较丰富，就需要大量的信息来描述，产生的文件就会非常巨大。所以通常情况下SVG都是些简单的图像。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>&emsp;&emsp;每张图片都是由一个或者多个数据通道构成。通常说的RGB图像就是由三个（红、绿、蓝）数据通道构成。灰度图像只有一个通道，灰度图像可以看出黑白是根据灰度值0~255（值2越小越接近黑，越大越接近白）。</p>
]]></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>尝试</tag>
      </tags>
  </entry>
  <entry>
    <title>JS遍历数组方法</title>
    <url>/2020/03/22/JS-arrayTraverse/</url>
    <content><![CDATA[<p>&emsp;&emsp;简单汇总下JavaScript遍历数组的方法：</p>
<h2 id="一、for"><a href="#一、for" class="headerlink" title="一、for"></a>一、for</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'h'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;len = arr.length,i &lt; len;i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;老生常谈的方法，如果不对数组长度进行更改可以先将长度保存起来，优化性能。</p>
<h2 id="二、for-in"><a href="#二、for-in" class="headerlink" title="二、for in"></a>二、for in</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'h'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(arr[i]) <span class="comment">// 'h','u','i'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;for in 可以将数组或者对象遍历一遍，i表示每次循环中对应的键（’h’键是0，’u’是1，’i’是2…）。某些时候，循环顺序是随机的。</p>
<h2 id="三、for-of"><a href="#三、for-of" class="headerlink" title="三、for of"></a>三、for of</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'h'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 'h','u','i'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与for in 很相似，不过i对应的是值。可以配合break、continue与return。在遍历数组或者可迭代对象时使用for of显得更为合适。</p>
<h2 id="四、forEach"><a href="#四、forEach" class="headerlink" title="四、forEach"></a>四、forEach</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'h'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123;		<span class="comment">// 可以传入三个参数，参数名随意。</span></span><br><span class="line">    <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">    <span class="comment">// h 0 ["h", "u", "i"]</span></span><br><span class="line">    <span class="comment">// u 1 ["h", "u", "i"]						</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;forEach方法对数组每个元素执行一次传入的函数的操作。必须传入至少一个形参，表示正在处理的当前元素。第二个表示当前元素的索引，第三个时当前操作的数组。</p>
<h2 id="五、map"><a href="#五、map" class="headerlink" title="五、map"></a>五、map</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'h'</span>,<span class="string">'u'</span>,<span class="string">'i'</span>]</span><br><span class="line">arr.mep(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123;		   <span class="comment">// 可以传入三个参数，参数名随意。</span></span><br><span class="line">	<span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">    <span class="comment">// h 0 ["h", "u", "i"]</span></span><br><span class="line">    <span class="comment">// u 1 ["h", "u", "i"]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看起来forEach很相似，区别在于：forEach是可以直接在回调里更改原始数组的元素。map是有返回值的（返回新的数组，地址值不同）。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>JS方法</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery快速入门</title>
    <url>/2020/03/15/jQuery/</url>
    <content><![CDATA[<p>&emsp;&emsp;jQuery 是一个非常轻量级的 JavaScript 框架，设计宗旨“write Less，Do More”（写更少的代码，做更多的事）。jQuery 提供的 API 用起来比 DOM API 舒服太多，而且可以兼容 IE6，是一个非常值得学习的一个 JavaScript 库。下面我将自己实现一个超简洁版的 jQuery。</p>
<h2 id="一、选择网页元素"><a href="#一、选择网页元素" class="headerlink" title="一、选择网页元素"></a>一、选择网页元素</h2><p>&emsp;&emsp;jQuery 选择元素非常舒服，通常采用<code>$(*)</code>的方式获取。*可以是标签也可以是 CSS 选择器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span> (<span class="params">nodeOrSelector</span>)</span>&#123;	<span class="comment">// 给全局对象加一个$方法</span></span><br><span class="line">    <span class="keyword">let</span> nodes = &#123;&#125;	<span class="comment">// 可能需要操作多个节点，所以初始化节点为对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">"string"</span>)<span class="comment">// 判断传的参数是否为字符串（CSS选择器）</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector);<span class="comment">// 用DOM API获取节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i];	<span class="comment">// 将获取到的所有节点放入nodes</span></span><br><span class="line">    &#125;</span><br><span class="line">      nodes.length = temp.length;  <span class="comment">// 让nodes像个伪数组方便以后操作</span></span><br><span class="line">  	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> Node) &#123; <span class="comment">// 判断传入的参数是否为Node节点</span></span><br><span class="line">      nodes = &#123;</span><br><span class="line">        <span class="number">0</span>: nodeOrSelector,	<span class="comment">// 直接付给nodes伪数组</span></span><br><span class="line">      	length: <span class="number">1</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes	<span class="comment">// 将nodes对象暴露出去</span></span><br><span class="line">	 ···   <span class="comment">// 添加其它方法直接在后面加函数，操作nodes（获取的节点）即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 window 上加属性（函数），在函数内用到所有的变量名都与全局作用域内的变量无关，避免了污染全局作用域。只暴露出关键部分，细节在函数内其他人无法直接修改，避免出现问题。</p>
<h2 id="二、添加方法"><a href="#二、添加方法" class="headerlink" title="二、添加方法"></a>二、添加方法</h2><p>&emsp;&emsp;其实后面的方法都换汤不换药了，把完成某功能用 DOM API 操作元素的方法封装成函数即可。封装好的函数直接添加到 nodes 对象上，以后调用函数就是飞一般的感觉（一行代替几行甚至十几行）。</p>
<h3 id="addClass-方法"><a href="#addClass-方法" class="headerlink" title="addClass 方法"></a>addClass 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收传入的class（以数组的形式）</span></span><br><span class="line">  classes.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].classList.add(value); <span class="comment">// 遍历数组，依次将class加到节点上</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="ajax 方法"></a>ajax 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodes.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; url, method, body, Headers &#125;</span>) </span>&#123;	<span class="comment">// 接受请求必要的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;	   <span class="comment">// 返回Promise对象，方便异步操作</span></span><br><span class="line">      <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()；</span><br><span class="line">      request.open(method, url);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> Headers) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = Headers[key];</span><br><span class="line">        request.setRequestHeader(key, value);		  <span class="comment">// 设置请求头</span></span><br><span class="line">      &#125;</span><br><span class="line">      request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">            resolve(request.responseText);			  <span class="comment">// 请求成功时调用resolve</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">            reject(request);						  <span class="comment">// 请求失败时调用reject</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    request.send(body);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>框架</tag>
        <tag>JavaScript</tag>
        <tag>jQuery</tag>
        <tag>快速入门</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2020/03/08/JS-function/</url>
    <content><![CDATA[<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>&emsp;&emsp;代码优化的第一步通常是将关联性较高但是书写较为分散的代码封装成函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">n = a + b;</span><br><span class="line"><span class="comment">/* 优化成能实现求两数相加之和的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;假如需要多次用到相同的功能，不使用函数的话，就会使代码耦合度高（重复代码多）。而且同时还会用到大量的全局变量，容易造成意向不到的后果。函数可以将要实现的功能写在函数体内（花括号里面）。如上，每当要求两个值相加的结果时，没有必要重复声明变量、赋值、然后再求和。定义一个函数，实现两数相加的功能肯定是需要两个数的。就用 a、b 变量代替用户要传的数据，函数体内 a、b 的值就对应着参数（括号内的内容）。使用 return 将值返回到函数外，否则结果只能在函数体内。意味着外部无法访问，那么这个函数就没有意义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//返回值为3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;函数名加()来调用函数，括号内填的 a、b 的值成了 1、2，那么这次执行函数返回值为 3。返回值用一个变量存储就行了。用到了多少次求两数之和的功能，就替换成上面这句，非常方便。</p>
<h2 id="函数初步进阶"><a href="#函数初步进阶" class="headerlink" title="函数初步进阶"></a>函数初步进阶</h2><h3 id="1、arguments"><a href="#1、arguments" class="headerlink" title="1、arguments"></a>1、arguments</h3><p>&emsp;&emsp;给函数传的参数（调用时填的值）的集合叫做 arguments 的对象内。这个对象大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用函数(实参1,实参2,实参3)  此时的arguments如下</span></span><br><span class="line"><span class="built_in">arguments</span> = &#123;</span><br><span class="line">    <span class="string">'0'</span>: 实参<span class="number">1</span>,</span><br><span class="line">    <span class="string">'1'</span>: 实参<span class="number">2</span>,</span><br><span class="line">    <span class="string">'2'</span>: 实参<span class="number">3</span>,</span><br><span class="line">    length: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是一个伪数组（数据结构像数组但是不能使用数组特有的方法）。可以在运行代码是更改其值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 返回5</span></span><br></pre></td></tr></table></figure>

<h3 id="2、this"><a href="#2、this" class="headerlink" title="2、this"></a>2、this</h3><p>&emsp;&emsp;函数都有 this，this 就是当前调用这个函数的<strong>值</strong>，因此这个值是可以随时变化的。要更快的掌握 this，还是要从 JavaScript 函数调用方式说起。JavaScript 函数调用可以直接在函数名后面加()，这是简便写法。使用.call()调用才是 JavaScript 正真的调用方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>，<span class="number">2</span>)等价于</span><br><span class="line">sum.call(<span class="literal">undefined</span>，<span class="number">1</span>，<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">obj.sum(<span class="number">1</span>,<span class="number">2</span>)等价于</span><br><span class="line">sum.call(obj,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 其中 obj 会被当做 this，1,2 会被当做 arguments</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;怎样判断当前 this 是什么？将它转换为.call 的形式。那为什么有时候我看 this 是 window？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">e(); <span class="comment">// 返回window</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当函数直接写在全局范围，也就是说没有写在其它函数内时，同时它又是直接调用的。其实 this 还是 undefine，不过浏览器将它改成了 window。操作 DOM 的时候也会用到函数，函数中的 this 是触发事件的元素。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面向对象</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript内存</title>
    <url>/2020/03/01/JS-ram/</url>
    <content><![CDATA[<p>&emsp;&emsp;写代码的目的是什么？是用代码写出经过编译后机器可以执行的命令（二进制流），根本之处在于数据。代码都存放在代码区，数据存储在数据区。那么数据在内存中是怎么存储的呢？在<code>JavaScript</code>中数据分为基本类型和引用类型。基本类型存储在栈（stack）内存中，引用类型存储在堆（Heap）内存中。什么是栈，什么是堆？它们是计算机存储数据的方式，也就是数据结构。当用代码声明一个变量，其实就是向内存申请空间，给它赋值了那么就是存储数据。数据在内存中存放的形式，就是数据的结构。这两个结构是怎样存储的？栈内存在存储数据如：</p>
<p><img src="stack.png" alt="stack"></p>
<p>&emsp;&emsp;栈就好比一个木桶，往里面一个一个放东西，往外面拿的时候最先放进去的因为在桶底（栈底）所以最后被拿出来。基本类型的数据存储的结构就是如此，在存储基本数据的栈内存中数据就是一个一个进去，后进先出。基本类型的数据直接存储在栈内存中。当理解存储结构后看到代码就可以这样理解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// b = 1</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>&quot;var a&quot;</code>就是向内存申请空间，需要注意：<code>“a”</code>并没有直接存储在内存中，它只是与内存中的数据相关联的标识。<code>“a”</code>因为是基本类型所以<strong>数据直接存储在栈内存</strong>。这个 1 占多大？<code>JS</code>中所有任何数字都以 64 位浮点数形式存储。这 64 位才存一个“1”有点浪费，不过这不不是重点。将<code>“a”</code>赋值给<code>“b”</code>，实际上是将<code>“a”</code> 的数据直接拷贝过来，改变<code>“b”</code>的值，<code>”a“</code>不会变。当然，前提是“a”存储的数据是存储在栈空间中的基本类型数据。</p>
<p>&emsp;&emsp;引用类型就是由基本类型组合而成的，引用类型里面还可以放任意多个引用类型的数据。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    	age: <span class="number">18</span>,</span><br><span class="line">    	profession: &#123;</span><br><span class="line">    		position: doctor</span><br><span class="line">			experience: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么，引用类型就理所应当处于更大的空间中。假如设一个有很多属性的对象存储在栈内存，需要修改属性时，在需要修改的数据之后存储的数据一个一个被拿出来，修改好后再放回去。这多影响性能啊，所以引用类型存储在堆内存中。堆内存比栈内存要大，存储的方式如下图：</p>
<p><img src="heap.png" alt="heap"></p>
<p>&emsp;&emsp;创建对象，就是在堆内存开辟空间。这个堆内存中又有两个部分，一个部分存储数据，一个部分存储这个空间所在内存中的地址，访问这个对象就是通过这个地址值。访问堆内存要通过栈内存，也就是说前面代码中将对象赋值给<code>Person</code>，并非直接存储堆内存中的对象。而是将这个对象的地址值存放在栈内存中，通过<code>Person</code>找到栈内存中的地址，通过这个地址找到对应的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">    gender: <span class="string">"male"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaofang = xiaoming</span><br><span class="line">xiaofang.gender = <span class="string">"female"</span></span><br><span class="line"><span class="built_in">console</span>.log(xiaoming.gender) <span class="comment">//female</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将<code>xiaoming</code>拷贝给<code>xiaofang</code>，其实是拷贝的栈内存中的地址值。与基本类型一样，赋值就是将存储在栈内存中的东西拷贝一份。不过，基本类型的数据直接存储在栈内存，因为拷贝的是数据，所以互不影响。引用类型在栈内存中存放的只是地址值，所以赋值后它们引用的同一个地址值。也就是说它们不止数据一样，如果修改一个，会影响其它相同地址值的对象。<br>&emsp;&emsp;总结以下：JavaScript 中，基本类型的数据存放在栈内存中，引用类型的数据存放在堆内存中。访问对象要先通过标识符访问栈内存中的地址值，通过地址值访问对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 判断数据类型</title>
    <url>/2020/02/22/JS-DataType/</url>
    <content><![CDATA[<p>&emsp;&emsp;JavaScript是一个弱类型语言，不需要声明变量的类型，意为着一个变量可以存储任意类型的数据。代码执行的时候数据的类型由JS引擎自动确定。JS中数据分为基本类型和引用类型。基本类型有<code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code><em>（新标准中增加了<code>symbol</code>和<code>BigInt</code>类型）</em>。引用类型有<code>object</code>、<code>function</code>、<code>array</code>，其实<code>function</code>和<code>array</code>本质上也是对象（<code>object</code>）。</p>
<p>&emsp;&emsp;怎样可以知道一个变量存储的数据是什么类型呢？通常使用<code>typeof</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">typeof</span>(a)      <span class="comment">//返回number		typeof a 与 typeof(a)等效</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'data'</span></span><br><span class="line"><span class="keyword">typeof</span>(b)      <span class="comment">//返回string</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span>(c)      <span class="comment">//返回boolean		</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span></span><br><span class="line"><span class="keyword">typeof</span>(t)      <span class="comment">//返回object</span></span><br><span class="line"><span class="keyword">var</span> d = [<span class="number">1</span>,<span class="string">'data'</span>,<span class="literal">true</span>]</span><br><span class="line"><span class="keyword">typeof</span>(d)	   <span class="comment">//返回object</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;是不是从第8行开始有点疑惑？前面不是说的<code>null</code>是基本类型吗，为什么返回的是<code>object</code>呢？或者说什么时候<code>typeof</code>会返回<code>object</code>？<code>null</code>与<code>undefined</code>的意思有点类似，它们有什么区别呢？其实这是历史遗留的问题，不用太过深究。声明了一个变量但是没有赋值，那么它初始值就是<code>undefined</code>，如果赋值一个对象，那么就是<code>object</code>。 <code>null</code>的定义是一个未设置对象的值的值。说白了，一个变量打算是对象，但是还未想好属性值。那么就给它赋值<code>null</code>，代表这个变量以后存储的是对象。第10行说明如果判断基本类型，<code>typeof</code>够用。但是引用类型如果要判断具体类型的话，不一定。复杂类型应该使用<code>instanceof</code>，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> d = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>		<span class="comment">//返回true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span>		<span class="comment">//返回true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="built_in">Function</span>	<span class="comment">//返回true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>     <span class="comment">//返回false</span></span><br><span class="line">e <span class="keyword">instanceof</span> <span class="built_in">Number</span> 	<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;用它同样可以判断基本类型的数据，那为什么先用<code>typeof</code>举例子引出<code>instanceof</code>呢？因为<code>instanceof</code>在判断基本类型时，不是用new声明的类型，就返回<code>false</code>，<code>null</code>和<code>undefined</code>都是返回<code>false</code>。综上所述，判断一个变量是什么类型时通常使用<code>typeof</code>，然后用<code>instanceof</code>。基本类型用<code>typeof</code>，引用类型用<code>instanceof</code>。</p>
<p>&emsp;&emsp;JS可以把基本类型临时转换成对象，于是偶然间发现</p>
<p><img src="20200303010919.png" alt=""></p>
<p>&emsp;&emsp;也就是说可以通过判断构造函数来判断数据类型了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a.constrructor === <span class="built_in">Number</span>  <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不过<code>undefined</code>和<code>null</code>不能用此方法。</p>
<p>&emsp;&emsp;通过某个对象调用<code>toString</code>方法也可以判断，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c = []</span><br><span class="line"><span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">toString.call(a)	    <span class="comment">//返回[object Number</span></span><br><span class="line">toString.call(b)		<span class="comment">//返回[object Object]</span></span><br><span class="line">toString.call(c)		<span class="comment">//返回[object Array]</span></span><br><span class="line">toString.call(d)		<span class="comment">//返回[object Function]</span></span><br><span class="line"><span class="comment">//用apply效果自然也是一样的</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>ES 5</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap快速入门</title>
    <url>/2020/02/15/Bootstrap/</url>
    <content><![CDATA[<h4 id="一、什么是-Bootstrap"><a href="#一、什么是-Bootstrap" class="headerlink" title="一、什么是 Bootstrap"></a>一、什么是 Bootstrap</h4><p>&emsp;&emsp;<code>Bootstrap</code> 是一个前端开发框架。自定义了很多 <code>CSS</code> 样式和 <code>JavaScript</code> 插件，使用这些样式和插件可以快速做出页面。只要有 <code>CSS</code> 与 <code>HTML</code> 基础就可以使用。<code>Bootstrap</code> 有一个特点是响应式布局，同一个页面同时支持 PC 和移动端，浏览器兼容性也十分不错。</p>
<h4 id="二、使用-Bootstrap"><a href="#二、使用-Bootstrap" class="headerlink" title="二、使用 Bootstrap"></a>二、使用 Bootstrap</h4><h4 id="emsp-emsp-1、基本模板（官方文档复制）"><a href="#emsp-emsp-1、基本模板（官方文档复制）" class="headerlink" title="&emsp;&emsp;1、基本模板（官方文档复制）"></a>&emsp;&emsp;1、基本模板（官方文档复制）</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 101 Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 代码写在这个位置 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="emsp-emsp-2、使用官方插件"><a href="#emsp-emsp-2、使用官方插件" class="headerlink" title="&emsp;&emsp;2、使用官方插件"></a>&emsp;&emsp;2、使用官方插件</h6><p>&emsp;&emsp;基本模板有了，怎么用呢？<code>CRM</code>（Copy Run Modify）,从官网复制实例到本地，运行正常就修改。做一个好看的轮播图用原生 <code>JS</code> 还是要花些时间，<code>Bootstrap</code> 官网的 JS 插件不错，复制过来<img src="20200218110651.png" alt="20200218110651"></p>
<p>&emsp;&emsp;通过注释可以看出图片应该是在 <code>Wrapper for slides</code> 与 <code>Controls</code> 之间。两个结构相似的代码片段，删掉其中根据页面变化可以看出下面的结构就是放置图片的地方。添加一段代码（如下）就可以多一个图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./image/timg_3.jfif"</span> <span class="attr">alt</span>=<span class="string">"..."</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 修改src添加图片 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"carousel-caption"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只能添加三个图片？通过删除与添加会发现下面代码片段（也就是 <code>Indicators</code> 部分）是控制图片数量的，与 <code>Wrappper fo slids</code> 是对应的。添加一个 <code>li</code>，就可以多添加一个 <code>items</code> 也就是添加图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">data-target</span>=<span class="string">"#carousel-example-generic"</span> <span class="attr">data-slide-to</span>=<span class="string">"2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="20200218115558.png" alt=""></p>
<p>&emsp;&emsp;通过复制，删除就可以轻松的使用官网的插件。</p>
<h6 id="emsp-emsp-3、使用预定义样式"><a href="#emsp-emsp-3、使用预定义样式" class="headerlink" title="&emsp;&emsp;3、使用预定义样式"></a>&emsp;&emsp;3、使用预定义样式</h6><p>&emsp;&emsp;在<a href="https://v3.bootcss.com/css/" target="_blank" rel="noopener">Bootstrap ３官方文档</a>中找到”全局 CSS 样式”，可以看到很 <code>Bootstrap</code> 预设的很多样式。以按钮为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">role</span>=<span class="string">"button"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Input"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;页面中的按钮通常是以这些标签做的，默认的样式都不怎么好看。引入了 <code>Bootstrap</code> 后直接给这些标签添加 class 名如：<code>btn</code> 、<code>btn-default</code>之类的就会发现样式变成 <code>Bootstrap</code> 预定义的样式。</p>
<p><img src="20200218114339.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-link"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">role</span>=<span class="string">"button"</span>&gt;</span>（链接）Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-warning"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>（警告）Warning<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-danger"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"（危险）Danger"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-success"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"（成功）Success"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看出，<code>Bootstrap</code> 就是通过控制样式依靠添加或者删除类名来增加或删除预设样式。</p>
<p><img src="20200218115239.png" alt=""></p>
<h4 id="三、Bootstrap-栅格系统"><a href="#三、Bootstrap-栅格系统" class="headerlink" title="三、Bootstrap 栅格系统"></a>三、Bootstrap 栅格系统</h4><p>&emsp;&emsp;前面说到，响应式布局是 <code>Bootstrap</code> 的一个特色，那么怎么做到呢？<code>Bootstrap</code> 在页面中创建行，每一行分为 12 列（有行有列，不就可以看作是栅格吗）。可以指定元素在不同分辨率下占几列。例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"col-lg-1 col-md-3 col-sm-6 col-xs-12"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"height: 20px;background-color: pink;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	col-lg-1代表在宽度 &gt;= 1200px的屏幕，通常来说是台式机显示器下占1个格子。也就是1/12行；</span></span><br><span class="line"><span class="comment">	col-md-3代表在宽度 &lt;= 992px的屏幕，通常来说是笔记本显示器下占3个格子。也就是1/4行；</span></span><br><span class="line"><span class="comment">	col-sm-6代表宽度 &gt;= 768px的屏幕，通常来说是平板的屏幕下占6个格子。也就是一行的一半；</span></span><br><span class="line"><span class="comment">	col-xs-12代表宽度 &lt; 768px的屏幕，通常来说是手机屏幕下占12个格子。也就是一行；</span></span><br><span class="line"><span class="comment">	如果将col-lg-1去掉，那么当屏幕宽度大于768px后，无论屏幕多宽永远都只能占屏幕的一半</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果一行没有占满，元素会右对齐，想让它居中怎么办？用偏移。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"col-md-6 col-md-offset-3"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">"height: 20px;background-color: pink;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 左右都会有3个格子，这样就是居中效果 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&emsp;&emsp;<code>Bootstrap</code> 是一个入门（复制粘贴）容易，不过想完全驾驭还是需要一定水平的。网上不少人认为 Bootstrap 主要用于快速制作网页，面对项目中的设计稿通常不太适合用 <code>Bootstrap</code>。闲时学习 <code>Bootstrap</code> 的设计思想和代码分类方式对前端水平提升是非常不错的。</p>
]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>布局</tag>
        <tag>框架</tag>
        <tag>快速开发</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2020/01/16/flex/</url>
    <content><![CDATA[<h3 id="一、flex-基本概念与常见属性"><a href="#一、flex-基本概念与常见属性" class="headerlink" title="一、flex 基本概念与常见属性"></a>一、<code>flex</code> 基本概念与常见属性</h3><p>&emsp;&emsp;刚接触 <code>flex</code>时，看到网上的各种视频或者文档教程，都略显冗长，因为一时半会儿压根不可能接受那么多东西，所以建议先将 <code>flex</code> 的概念做个大致了解，然后找案例跟着敲。</p>
<p><img src="flex.png" alt="flex"></p>
<p>&emsp;&emsp;我尽量说的通俗易懂，将一个标签 <code>display</code> 的值改为 <code>flex</code> 后，该容器就成了一个弹性盒子 <code>container</code> 。在 <code>container</code> 里面的子标签就成了 <code>item</code> (子项)。这个盒子默认情况下有两个轴，一个是 <code>cross axis</code> (主轴)，一个是 <code>cross axis</code> (一般称为交叉轴，为了方便这里叫它侧轴)。主轴默认是从左到右，侧轴从上到下。轴开始和结束被称为 <code>cross start</code> 和 <code>cross end</code> 所有子项默认情况下都是沿着主轴排列，单个子项所占据主轴的空间叫做 <code>main size</code> ，占据侧轴的空间叫做 <code>cross size</code> 。利用 <code>flex</code> 可以十分快捷并且灵活的布局。常见属性如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 父容器常用属性 */</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>; <span class="comment">/* 决定主轴方向，默认横向从左到右 */</span></span><br><span class="line"><span class="selector-tag">flex-wrap</span>: <span class="selector-tag">nowrap</span>; <span class="comment">/* 决定容器内子项是否换行，默认不换行 */</span></span><br><span class="line"><span class="selector-tag">flex-flow</span>: <span class="selector-tag">row</span> <span class="selector-tag">nowrap</span>; <span class="comment">/* 前两个属性的简写 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">flex-start</span>; <span class="comment">/* 定义子项在主轴的对齐方式,默认为左对齐 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">stretch</span>; <span class="comment">/* 定义多根轴线的对齐方式，如果只有一根轴线，改属性无效 */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">stretch</span>; <span class="comment">/* 定义子项在侧轴上的对齐方式，默认项目未设置高度时将占满整								  			个容器的高度 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 子项目常用属性 */</span></span><br><span class="line">    <span class="selector-tag">flex</span>: <span class="selector-tag">none</span>					 <span class="comment">/* 将容器分成几份，该项所占的份数 */</span></span><br><span class="line">    <span class="selector-tag">order</span>: 0;					 <span class="comment">/* 定义子项排列顺序,数值越小排列越靠前 */</span></span><br></pre></td></tr></table></figure>

<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li><p>不控制子项的大小时，子项会根据父容器的大小撑满父容器。</p>
</li>
<li><p>父容器内只有在普通流的元素才会成为子项，并非所有元素都是子项。</p>
</li>
<li><p>使用 <code>flex</code> 后，<code>float</code>、<code>clear</code>以及 <code>vertical-align</code> 属性将会失效</p>
</li>
<li><p>可以将子项的 <code>display</code> 值改为 <code>flex</code> (嵌套)</p>
</li>
<li><p>如果元素标签的子级用的是 flex 布局，当前元素的上一级（也就是当前元素的父级）不能使用<code>positon: absolute/fixed</code></p>
</li>
<li><p><code>flex</code>在移动端兼容性非常好，PC 端最多只能兼容到 IE 9</p>
<p>以上内容，任何人第一次看都不可能有什么顿悟的感觉，毕竟理论是千篇一律的。鲁迅先生曾经说过:”碗酸辣汤，耳闻口讲的，总不如亲自呷一口的明白 。“</p>
</li>
</ul>
<h3 id="二、简单案例（只包含核心代码，通常需加上宽高颜色看效果）"><a href="#二、简单案例（只包含核心代码，通常需加上宽高颜色看效果）" class="headerlink" title="二、简单案例（只包含核心代码，通常需加上宽高颜色看效果）"></a>二、简单案例（只包含核心代码，通常需加上宽高颜色看效果）</h3><h6 id="emsp-emsp-1、水平垂直居中"><a href="#emsp-emsp-1、水平垂直居中" class="headerlink" title="&emsp;&emsp;1、水平垂直居中"></a>&emsp;&emsp;1、水平垂直居中</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/*父容器改为弹性盒子flexbox*/</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 元素在主轴方向居中对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 元素在侧轴方向居中对齐 */</span></span><br><span class="line">&#125; <span class="comment">/* 只有一个子元素，所以里面的div就绝对居中container */</span></span><br></pre></td></tr></table></figure>

<h6 id="emsp-emsp-2、导航栏"><a href="#emsp-emsp-2、导航栏" class="headerlink" title="&emsp;&emsp;2、导航栏"></a>&emsp;&emsp;2、导航栏</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>前端<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>DBA<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>大数据<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* flex容器内的元素默认不换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="emsp-emsp-3、flex-实现栅格布局"><a href="#emsp-emsp-3、flex-实现栅格布局" class="headerlink" title="&emsp;&emsp;3、flex 实现栅格布局"></a>&emsp;&emsp;3、<code>flex</code> 实现栅格布局</h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 一个div代表一个栅格 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基础部分 */</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 容器内元素平均分配空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码是平均分布不换行的，可以将父容器指定宽度后将 <code>flex-wrap</code> 属性更改为 <code>wrap</code> ，并且指定子项的宽度即可做成一个栅格。如下图。</p>
<p><img src="flex-grid.png" alt=""></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>&emsp;&emsp;<code>flex</code>布局核心就是将元素 <code>display</code> 属性值改为 <code>flex</code> 后,通过调整主轴、侧轴的方向以及子项的位置和排列方式等来布局。掌握了常用属性后 <code>flex</code> 会改变你对布局的看法，其实掌握 <code>flex</code> 费时间的主要在于记属性。硬生生的记十几个属性实在是枯燥，所以这里推荐一个网站——<a href="https://flexboxfroggy.com/#zh-cn" target="_blank" rel="noopener">FLEXBOX FROGGY</a>通过游戏的方式可以很快的记住。通关后可以用 <code>flex</code> 仿做个移动端页面( <code>flex</code> 在移动端非常流行)，我仿做过一个携程页面）可以参考下（<a href="https://github.com/huiboxes/ctrip.m" target="_blank" rel="noopener">点这儿去</a>）。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS布局</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>Github使用方法</title>
    <url>/2019/12/29/githubTutorial/</url>
    <content><![CDATA[<h4 id="声明：本文以实际使用的角度出发，因为短时间内是不太好理解的，使用一定时间后自然就理解了，刚开始比较无趣，只有背命令。纸上得来终觉浅，绝知此事要躬行。"><a href="#声明：本文以实际使用的角度出发，因为短时间内是不太好理解的，使用一定时间后自然就理解了，刚开始比较无趣，只有背命令。纸上得来终觉浅，绝知此事要躬行。" class="headerlink" title="声明：本文以实际使用的角度出发，因为短时间内是不太好理解的，使用一定时间后自然就理解了，刚开始比较无趣，只有背命令。纸上得来终觉浅，绝知此事要躬行。"></a><strong>声明：本文以实际使用的角度出发，因为短时间内是不太好理解的，使用一定时间后自然就理解了，刚开始比较无趣，只有背命令。纸上得来终觉浅，绝知此事要躬行。</strong></h4><h5 id="Github是什么？"><a href="#Github是什么？" class="headerlink" title="Github是什么？"></a>Github是什么？</h5><p>&emsp;&emsp;Github是一个代码托管平台，可以通过此平台找到许多开源项目，可以共享自己的开源项目与他人共同开发、完善，由于只支持Git的版本库格式进行托管，所以名为Github。</p>
<h5 id="Git是什么？工作流程是什么？"><a href="#Git是什么？工作流程是什么？" class="headerlink" title="Git是什么？工作流程是什么？"></a>Git是什么？工作流程是什么？</h5><p>&emsp;&emsp;Git是一个开源的分布式版本控制系统。了解工作流程首先要知道四个东西：</p>
<ul>
<li><p>Workspace：工作区</p>
</li>
<li><p>index/Stage：暂存区</p>
</li>
<li><p>Repository：仓库区</p>
</li>
<li><p>Remote：远程仓库</p>
<p>&emsp;&emsp;工作流程如下：在工作区中修改某些文件 → 对修改后的文件进行快照，然后保存到暂存区(add) → 提交更新，将保存在暂存区域的文件快照永久转储到Git目录中(仓库)(commit) → 将本地仓库push到远程仓库(push)</p>
</li>
</ul>
<h5 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h5><p>&emsp;&emsp;1.安装Git Bash：在 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a> 下载，然后一直下一步就好。</p>
<p>&emsp;&emsp;2.注册Github账户：点这里进入<a href="github.com">官网</a>,英语不好的建议用chrome，翻译挺好用的。注册时全部默认下一步即可，注册完账号就创建一个新仓库，别的都不管，直接默认的选项点下一步即可，等后面没事了一定要有空就打开看看，每个都按一下，摸索一下(不要删除仓库和账号就好)。</p>
<h5 id="二、配置Git-Bash："><a href="#二、配置Git-Bash：" class="headerlink" title="二、配置Git Bash："></a>二、配置Git Bash：</h5><p>&emsp;&emsp;在命令行依次在输入下面的内容，输一行，按一次回车。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "huibox"				  #上传用户的称呼</span><br><span class="line">git config --global user.email "huiboxes@gmail.com"	  #上传用户的邮箱</span><br><span class="line">git config --global push.default simple				  #更改push方式</span><br><span class="line">git config --global core.quotepath false			  #防止文件名变成数字</span><br><span class="line">git config --global core.editor "vim"				  #使用vim编辑提交信息</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在任何地方只需要右击鼠标，然后选Git Bash here即可打开一个命令行界面，默认情况打开后就处于当前文件所在位置。命令行内可以运行简单的Linux命令。</p>
<h5 id="三、配置Github"><a href="#三、配置Github" class="headerlink" title="三、配置Github"></a>三、配置Github</h5><h6 id="1、获取SSH公钥"><a href="#1、获取SSH公钥" class="headerlink" title="1、获取SSH公钥"></a>1、获取SSH公钥</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.ssh/*										  #单击鼠标右键点击Git Bash here后输入</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;千万不能输错，不然就可能要重装系统了，回车后输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -c "huiboxes@gmail.com"     #生成ssh key</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;按三次回车，得到ssh key。直接按，这个环节不会有任何错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub 								  #屏幕上输出ssh公钥</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将打印出的内容全部复制下来，在bash终端下复制快捷键为<code>ctrl+insert</code>。在根目录下的.ssh目录中有两个文件，id_rsa是私钥，不要给任何人。</p>
<h6 id="2、在Github添加公钥"><a href="#2、在Github添加公钥" class="headerlink" title="2、在Github添加公钥"></a>2、在Github添加公钥</h6><p>&emsp;&emsp;打开<a href="https://github.com/settings/keys" target="_blank" rel="noopener">https://github.com/settings/keys</a>  。点击<code>New SSH key</code>按钮，<code>title</code>随便输入什么，在<code>key</code>下的表单内粘贴刚刚复制的内容，点<code>Add SSH key</code>。</p>
<h6 id="3、测试是否已对接"><a href="#3、测试是否已对接" class="headerlink" title="3、测试是否已对接"></a>3、测试是否已对接</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com								   #打开Git Bash后输入</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果提示输入yes/no就输入yes，只要没有看到一串包含successfully的英文，就要重第一步重新弄。</p>
<ul>
<li>​    如果把key从电脑上删除了，重新生成一个就好了，替换之前的key。</li>
<li>​    一个电脑只需要一个key。</li>
<li>​    其他设备如果想的key上传到Github可以和之前的 key共存在Github上</li>
<li>​    一个key可以访问所有的仓库。</li>
</ul>
<h5 id="四、使用Git"><a href="#四、使用Git" class="headerlink" title="四、使用Git"></a>四、使用Git</h5><h6 id="1、本地仓库的使用-跟着敲会有奇效"><a href="#1、本地仓库的使用-跟着敲会有奇效" class="headerlink" title="1、本地仓库的使用(跟着敲会有奇效)"></a>1、本地仓库的使用(跟着敲会有奇效)</h6><p>&emsp;&emsp;在你认为合适的盘符下创建一个文件夹，进入该文件夹右击鼠标点Git Bash here。然后输入<code>git init</code><strong>初始化</strong>本地仓库，这个文件夹就成了工作区。使用命令行就简单多了，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /f								#进入f盘（路径随意）</span><br><span class="line">mkdir fileName						#在当前目录创建名为"fileName"的文件夹（名字叫什么都可以）</span><br><span class="line">cd    fileName						#进入fileName目录</span><br><span class="line">git init							#初始化本地仓库</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;fileName文件夹内会多出一个名为<code>.git</code>的隐藏文件夹，对该文件夹下内容的任何改动都会被git记录，不要动这个隐藏文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch test							#创建名为test的空文件=windows右键创建没有后缀名的文件</span><br><span class="line">git status -sb						#查看当前目录文件状态</span><br></pre></td></tr></table></figure>

<p>![](git status.png)</p>
<p>&emsp;&emsp;可以看到所创建的文件名前会有两个<code>??</code>。因为你还没有对该文件进行过git操作，git不知道你后面会怎样对待这些文件的变动（增加、删除、更改都是变动）。</p>
<p><img src="gitadd.png" alt=""></p>
<p>&emsp;&emsp;使用<code>git add 你创建的文件名</code>将某个文件<strong>添加</strong>到<strong>暂存区</strong>，使用<code>git add .</code>将当前目录里面所有的变动都加到暂存区。再次使用<code>git status -sb</code>会看到<code>??</code>变成了A(即Add添加)。</p>
<p>![](git commit.png)</p>
<p>&emsp;&emsp;使用<code>git commit 你创建的文件名 -m &quot;注释信息，方便以后查看&quot;</code>将某个文件<strong>提交</strong>到<strong>本地仓库</strong>，使用<code>git commit .  -m &quot;注释&quot;</code>将当前目录里文件都提交到本地仓库。这时再使用<code>git status -sb</code>会发现A变成了<code>M</code>(即Modified修改)。</p>
<h6 id="2、将本地仓库上传到Github"><a href="#2、将本地仓库上传到Github" class="headerlink" title="2、将本地仓库上传到Github"></a>2、将本地仓库上传到Github</h6><p>&emsp;&emsp;在文章开头就提到过在Github创建一个仓库，就是为了这一步。进入仓库首页复制你的仓库地址。</p>
<p><img src="github.png" alt=""></p>
<p>&emsp;&emsp;选这个SSH因为用HTTPS的话以后每次更新都要输入密码。之前上传SSH公钥就是为了用SSH。接下来依次在命令行输入下面的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:huiboxes/test.git	#可以在github复制然后在命令行粘贴</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;刷新Github你会发现你的仓库上传上去了。</p>
<h6 id="3、将Github上的仓库克隆到本地"><a href="#3、将Github上的仓库克隆到本地" class="headerlink" title="3、将Github上的仓库克隆到本地"></a>3、将Github上的仓库克隆到本地</h6><p>&emsp;&emsp;找到一个觉得不错的开源仓库或者自己创建个新仓库，打开仓库首页单击<code>Clone or download</code>复制SSH地址，进入一个你想作为存放工作区的文件夹输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone 粘贴刚刚复制的地址</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;运行完后会发现文件夹内多出一个与你github上仓库同名的文件夹。将工作区内的变更(增加、删除、改动都是变更)上传到Github的话，只需加上<code>git pull</code> 与<code>git push</code>。完整流程如下：</p>
<p>&emsp;&emsp;<strong>git add  → git commit → git pull  → git push</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>实用网站</tag>
      </tags>
  </entry>
  <entry>
    <title>浮动与定位</title>
    <url>/2019/12/20/floatAndposition/</url>
    <content><![CDATA[<h5 id="一、浮动"><a href="#一、浮动" class="headerlink" title="一、浮动"></a>一、浮动</h5><p>&emsp;&emsp;普通流中，因为div是块级元素所以是单独占据一行的，假如我想让两个div在同一行显示怎么办？除了将div改成内联元素外，也可以使用浮动。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">float: none || left || right || inherit;</span><br><span class="line"><span class="comment">/* (默认，就是不浮动)、left(左浮动)、right(右浮动)、inherit(继承父元素的float属性值)。 */</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;设置浮动后它本身会尽可能向左或者右移动，直到碰到边框或者其他的浮动元素。原理是处于普通流的元素会忽略这个浮动的元素紧跟上一个同样处于普通流的元素排版。这样就会造成浮动的元素遮盖住后面仍然处于普通流的元素。以PS图层的概念来理解的话就很好理解了，所有的普通流元素都在同一层，使用浮动后的元素会”浮“上一层，在普通流之上。 不过要注意的是，文字仍然会认为这个浮动的元素存在，为什么呢？其实float设计的初衷是用来实现文字环绕图片的效果(包含文字的元素忽略这个浮动图片，但是文字认为浮动的元素还存在就绕开它排版)。设置浮动后会出现几个现象。</p>
<ul>
<li>脱离普通流</li>
<li>自动变为块级元素</li>
<li>父容器高度会塌陷也就是父容器height值会变成0(因为仍然处于普通流认为这个浮上去的元素已近不存在了，     随之带来父容器背景无法发显示、margin值也会塌陷、边框无法撑开)</li>
</ul>
<p>&emsp;&emsp;显然父容器塌陷是我们不想看到的，就要清除浮动来解决。这里只演示一种方法。</p>
<p>&emsp;&emsp;添加一个新的元素，在新的元素里添加CSS属性——clear: both;意思是在这个元素的左右方向都不能出现浮动元素。不过这样突然添加一个元素的话对代码结构有影响，所以建议使用伪元素。例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.float</span>&#123;</span></span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.clearFix</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line">            content: '';</span><br><span class="line">            clear: both;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper .clearFix"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"float"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​       </p>
<h5 id="二、定位"><a href="#二、定位" class="headerlink" title="二、定位"></a>二、定位</h5><p>&emsp;&emsp;常使用的定位有relative、absolute。简单演示下定位方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line">            wdith: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: pink;</span><br><span class="line"><span class="css">            <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>; 		<span class="comment">/* 使用绝对定位，默认值为static，也就是没有定位 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">right</span>: ;					<span class="comment">/* 相对于父容器右边的距离 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">left</span>: ;						<span class="comment">/* 相对于父容器左边的距离 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">top</span>: ;						<span class="comment">/* 相对于父容器顶部的距离 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">bottom</span>: ; 					<span class="comment">/* 相对于父容器底部的距离 */</span></span></span><br><span class="line"><span class="css">       									<span class="comment">/* 可以是具体的值，比如px、em等，也可以是百分比 */</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>								    <span class="comment">&lt;!-- body也是标签，所以div的父容器是body --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>  <span class="attr">class</span>=<span class="string">“demo”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它们有一个共同的特点，就是都会脱离普通流。不同之处在于：<br>&emsp;&emsp;1、设置为<code>absolute</code>的元素会直接在普通流之上，不会影响普通流中的元素。使用<code>relative</code>后该元素虽然会在普通流之上，但是原来所处的位置仍然被占据着。可以这样理解，使用<code>absolute</code>的元素如同上了立交桥的车，从平面上看可以与任意桥下的车(普通流中的元素)重叠。使用<code>relativle</code>后那个车同样上了立交桥，同样可以与任意桥下的车重叠。但是，原来在桥下的停车位交了钱就一直保留着，桥下的车不能停在哪里。</p>
<p>&emsp;&emsp;2、absolute元素移动是相对于离它最近的定义了position属性（默认值不算）的父容器进行，如果父容器没有设置position属性，就往更外面设置了定位的盒子。假如它往上面找没有任何元素设置了positon属性，那么它就相对于浏览器窗口的大小来定位（无论body宽高多少）。</p>
<p>&emsp;&emsp;再最后补充一个position属性——fixed，在浏览网页时经常看到一直悬浮在窗口某个固定位置的小广告，这种小广告都是使用fixed属性的。脱离普通流，没钱买车位，但是比较霸道的是它是相对于浏览器窗口来定位的。需要注意的是：使用了fixed后，元素的宽度会向内收缩；当有父容器的transform给了属性值时，该元素就会从占据窗口位置变成相对设置了transform的父容器来定位。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>流与盒子模型</title>
    <url>/2019/12/11/flowAndBox/</url>
    <content><![CDATA[<h3 id="一、流"><a href="#一、流" class="headerlink" title="一、流"></a>一、流</h3><p>&emsp;&emsp;通常情况下，制作一个页面写的所有东西都是紧跟其前一个元素之后的，如同流水一般。如果是内联元素，从左往右排版，如果页面宽度不够，就换行继续。如果是块级元素，从上向下，每个元素都独占一行。这就是默认的布局方式——普通流，也叫常规流。页面的传统布局就是依靠控制流来实现横向、纵向布局。有常规流当然也有非常规的，使用浮动与定位后，元素会脱离普通流(浮动不是完全脱离)，也就是非常规流。这里的普通流不少地方也叫做文档流，其实文档流的说法是因为很多地方将CSS官方文档中的normal flow翻译错了，称为普通流的话更为专业。</p>
<p>&emsp;&emsp;前面提到脱离普通流，这个概念有点抽象。脱离普通流的元素与普通流中的元素的位置关系可以看作是PSD文件中不同的图层。可以通过<code>index</code>属性来调整脱离普通流后元素在第几层，使用定位后才能使用<code>index</code>属性。</p>
<h3 id="二、盒子模型"><a href="#二、盒子模型" class="headerlink" title="二、盒子模型"></a>二、盒子模型</h3><p>&emsp;&emsp;网页中所有的文字、图片等内容都是写在<code>HTML</code>标签内的，可以将这些标签看作是一个容器——盒子。这个盒子的大小是多少呢？默认情况下，如果是块级元素，高度与内容高度相等，与页面同宽。如果是内联元素，可以简单的看作与内容区域同宽高。通过<code>CSS</code>设置<code>width</code>属性、<code>height</code>属性控制这个盒子内部（内容区域）的宽高（内部空间大了，整个盒子自然也大了）。可以通过向这个盒子使用<code>padding</code>属性来添加填充，达到使内容相对于这个盒子居中的效果（既然是填充，当然不能在填充部分放东西）。通过<code>border</code>属性给盒子加边框，美化这个盒子。想控制每个盒子的间距，可以使用<code>margin</code>，控制这个完全透明的“隔板”的厚度。假如给盒子盒子固定的宽高，当内容大于盒子时，内容会溢出，盒子不会有任何变化。补充：前面说到网页中所有<code>HTML</code>标签都可看作是一个盒子，那么<code>body</code>标签算吗？算的，并且细心观察会发现<code>body</code>标签是自带8px的外边距的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">	div&#123;</span><br><span class="line"><span class="css">		<span class="selector-tag">width</span>: 20<span class="selector-tag">px</span>;				<span class="comment">/* 盒子内容区域宽度20像素 */</span></span></span><br><span class="line"><span class="css">		<span class="selector-tag">height</span>: 20<span class="selector-tag">px</span>;				<span class="comment">/* 盒子内容区域高度20px */</span></span></span><br><span class="line"><span class="css">		<span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">black</span> <span class="selector-tag">solid</span>;	<span class="comment">/* 给盒子四周加上1像素、黑色实线边框 */</span></span></span><br><span class="line"><span class="css">		<span class="selector-tag">padding</span>: 2<span class="selector-tag">px</span>;				<span class="comment">/* 给盒子内部四周填充2像素 */</span></span></span><br><span class="line"><span class="css">		<span class="selector-tag">margin</span>: 20<span class="selector-tag">px</span>;					<span class="comment">/* 给盒子外部四周加20像素间距 */</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	/* ==========================================================================</span><br><span class="line">       以上是复合属性，一次性同设置加盒子四周。想单独设置盒子某个方向的话在属性后加方向来单独设置</span><br><span class="line">       例如： </span><br><span class="line">       margin-top: 10px;		单独添加外上边距10像素</span><br><span class="line">       margin-right: 10px;		单独添加外右边距10像素</span><br><span class="line">       margin-bottom: 10px;		单独添加外下边距10像素</span><br><span class="line">       margin-left: 10px;		单独添加外左边距10像素</span><br><span class="line">       border与padding以此类推也是同样的方法。</span><br><span class="line">       ========================================================================== */</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面的盒子实际宽高是多少？</p>
<p>&emsp;&emsp;这要分情况，因为盒子模型分为两种，一种是W3C标准盒模型，还有一种在低版本IE环境下的IE盒模型。两者两者的区别在于W3C盒模型的宽高等于<strong>内容+填充+边框+边距</strong>的总和。IE盒模型的宽高等于<strong>内容+边距</strong>，IE盒模型的填充和边框呢？IE盒模型将填充和边框都算在内容区域的。如果找到Windows 2000系统的主机，用其自带的IE浏览器就会发现，同样的属性，在现代浏览器与低版本IE的宽高是不一样的。使用<code>box-sizing: border-box;</code>也可以有IE盒模型的效果。</p>
<p>&emsp;&emsp;上面的盒子按照W3C标准盒模型计算的话是：</p>
<p>&emsp;&emsp;因为宽高设置同样的值，所以宽高都是：<code>20+1*2+2*2+20*2=46px</code> ;按照IE盒模型计算的话，宽高：<code>20+20*2=40px</code>。怎样快速理解盒子模型？用尽量少的<code>div</code>标签画一个远视图。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS基础</tag>
        <tag>盒子模型</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS引入与选择器</title>
    <url>/2019/12/04/CSSreferenceAndSelector/</url>
    <content><![CDATA[<h6 id="一、CSS-引入"><a href="#一、CSS-引入" class="headerlink" title="一、CSS 引入"></a>一、CSS 引入</h6><p>&emsp;&emsp;掌握了 HTML 基础，已可以做出简单的页面，但是要做出更加精美的网页还是要依靠<code>CSS</code>，一个网页中所看到的字体、间距、颜色和部分特效等都是由<code>CSS</code>来实现的，通过选择器对文档某个部分添加样式。显然，<code>CSS</code>不能单独使用。把网页比作建房子的话，HTML 做出毛胚房，<code>CSS</code>来装修。<code>CSS</code>与<code>HTML</code>是两个语言，引入<code>CSS</code>就是将它们关联在一起。</p>
<p>&emsp;&emsp;<code>CSS</code>有四种引用方式：内嵌、内联、外联、导入。</p>
<p>​&emsp;&emsp;1）内嵌</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"color: pink;"</span>&gt;</span>Hellow world !!!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​ 给单个标签使用，因为十分具体所以优先级最高。但是当网页内容变多后，想要更改样式就比较费时间。不利于更改样式、不利于<a href="[https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fr=aladdin](https://baike.baidu.com/item/搜索引擎优化/3132?fr=aladdin)">SEO</a>。不建议使用这种方式。</p>
<p>​&emsp;&emsp;2）内联</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: pink;&#125;			<span class="comment">/* color为更改字体颜色 */</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;在<code>head</code>部分添加<code>style</code>标签，在标签内直接写<code>CSS</code>，在代码量少时为了方便可以这样，为了规范还是不建议使用这种方式。</p>
<p>​&emsp;&emsp;3）外联</p>
<p>​&emsp;&emsp;将 CSS 单独写在.css 文件中，通过 HTML 的<link>标签从外部导入到。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./style.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;符合“结构样式行为相分离”，规范并且便于后期维护。</p>
<p>​&emsp;&emsp;4）导入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在CSS文件导入 */</span></span><br><span class="line">@<span class="keyword">import</span> url(style.css);</span><br><span class="line"><span class="comment">/* 在html文件内导入 */</span></span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    @<span class="keyword">import</span> url(style.css);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;与外联相似，都是导入外部文件。不过导入优先级比外联低，过多使用会延长浏览器渲染页面的时间。</p>
<p>​&emsp;&emsp;优先级方面，内嵌 &gt; 内联 &gt; 外联 &gt; 导入。也就是说通常情况下如果同时用多种方法给同一个元素设置相同的属性但是不同的属性值时，会优先显示内嵌的样式，没有内嵌样式的话就是内联，接着是外联，最后就是导入。</p>
<h6 id="二、CSS-选择器"><a href="#二、CSS-选择器" class="headerlink" title="二、CSS 选择器"></a>二、CSS 选择器</h6><p>​&emsp;&emsp;上学的时候老师依靠同学的名字或者位置准确的叫某位同学回答问题。<code>CSS</code>也是如此,依靠选择器对网页中的每一个<code>HTML</code>元素添加样式。写代码讲究”高内聚弱耦合”,如果几行代码都实现同样的功能,可以简化就简化。所以选择器我就从范围最广到最小来介绍，最常见的选择器有以下几种：</p>
<p>​&emsp;&emsp;1、通配符选择器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">*&#123;							<span class="comment">/* 针对所有元素 */</span></span><br><span class="line">     <span class="attribute">margin</span>: <span class="number">0</span>;				<span class="comment">/* 所有元素边距为0 */</span>  <span class="comment">/*body、ol、table、form等标签自带maring*/</span></span><br><span class="line">     <span class="attribute">padding</span>: <span class="number">0</span>;			<span class="comment">/* 所有元素填充为0 */</span>  <span class="comment">/*option、textarea等标签自带padding*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;<code>*</code>在计算机中通常是当作通配符用的，代表 N 个字符(无论长短)。也就是说文档内所有元素都会被添加上通配符选择器内的<code>CSS</code>属性。为了方便布局，通常都会将所有元素自带的<code>margin</code>、<code>padding</code>都去掉。为了方便直接使用通配符选择器来完成，但是当页面内标签多的话理论上是影响页面性能的。生产环境中通常都会有“初始化<code>CSS</code>文件”，文件主要内容就是使用标签选择器具体指定某个标签清除自带样式。</p>
<p>​&emsp;&emsp;2、标签选择器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">a</span>&#123;							<span class="comment">/* 针对所有a标签 */</span></span><br><span class="line">	<span class="attribute">text-decoration</span>: none;	<span class="comment">/* 将所有a标签下划线去掉 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;直接在 HTML 某个标签后加花括号。网页中 HTML 中的 a 标签默认是带下划线并且是蓝色的,然而这显然不符合现代人的审美。通常都会用一个标签选择器来去掉下划线,改下字体样式。</p>
<p>​&emsp;&emsp;3、属性选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">input</span><span class="selector-attr">[name="danxuan"]</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 标签  +  [属性] */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">font-weight</span>: 700; <span class="comment">/* 针对input标签内有name属性并且值为duanxuan的标签 */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;如果用了标签选择器后想再具体点对带有某个属性的元素进行操作，可以使用属性选择器。类似于老师指定了班上的男同学打扫卫生，再单独指定长得高的都去擦窗户。</p>
<p>4、<code>class</code>选择器(类选择器)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line">      color: pink;</span><br><span class="line"><span class="css">    &#125; <span class="comment">/* 在class名前加个 .  */</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​&emsp;&emsp;在标签中加<code>class=&quot;class-name&quot;</code>，标签就有了自己的类名。多个标签可以有相同的类名。这个类名不能以数字、”-“和“_”开头，不过可以用中文甚至是 emoji 表情命名。当然，为了符合规范还是以有意义的单词来命名最好。给标签选择器加类名可以理解为将某些同学分到到指定的组，指定某个组的同学打扫卫生。</p>
<p>​&emsp;&emsp;5、<code>id</code>选择器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#demo</span> &#123;</span></span><br><span class="line">      color: pink;</span><br><span class="line"><span class="css">    &#125; <span class="comment">/* 在id名前加个 # */</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在标签中加<code>id=&quot;id-name&quot;</code> 标签就有了自己的<code>id</code>。多个标签可以有相同的 id 不过为了规范,通常一个<code>id</code>只给一个标签,保证其唯一性,就如同每个人的身份证号码一般。</p>
<p>小结：</p>
<p>&emsp;&emsp;在优先级方面，针对的对象多，优先级自然不会高。”唯一“的 id 选择器优先级最高。如下：</p>
<p>&emsp;&emsp;<strong><code>id</code>选择器&gt;<code>class</code>选择器&gt;属性选择器&gt;标签选择器&gt;通配符选择器</strong></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2019/11/10/firstblog/</url>
    <content><![CDATA[<p>&emsp;&emsp;一时兴起想弄个博客，个人空间吗，主要用于记录平时的学习、生活。时不时发一点所学的，或者新的感悟，等以后回过头看复习，或许也能勉励一下自己。为什么我不想用QQ空间了呢？我现在认为比起QQ空间来说Blog更加自由，更加的开放却又隐私。往后我可能会将每个月的周安排都发到Blog上，进一步提醒自己。<br>&emsp;&emsp;<img src="2019-11plan.png" alt=""><br>&emsp;&emsp;11月的bilibili要改成acfun了，因为听说Rick and Morty新一季要出来了。此外我打算囫囵吞枣的把Linux学一遍，如果有事找我，在上课和培训的时候我一般不会回复，等有时间了如果有能力我十分乐意帮忙解决。对了，这是我的第一篇Blog，有点小激动，可以在评论区留下你对我本人的看法、及意见。最好能留下对我的第一映像和我的缺点哦，十分感谢！</p>
]]></content>
      <categories>
        <category>心情</category>
      </categories>
      <tags>
        <tag>first</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
</search>
